<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Character Sheet Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=EB+Garamond:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/feather-icons"></script>
    <!-- SUPABASE CLIENT -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @media print {
            body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            .no-print { display: none !important; }
            .page-break { page-break-after: always; }
            .usage-box, .spell-slot-box { border: 1px solid #5c4d3d !important; }
            .usage-box:checked, .spell-slot-box:checked { background-color: #3a2d21 !important; }
            .sheet-container { border: none !important; box-shadow: none !important; height: 11in;}
            .sheet-wrapper { max-width: 100%; margin: 0; }
            #sheet-container-front header { display: grid !important; grid-template-columns: repeat(3, 1fr) !important; }
            #sheet-container-front header .header-main { grid-column: span 2 / span 2 !important; }
            #sheet-container-front main { display: grid !important; grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
            #sheet-container-front main > div { grid-column: span 1 / span 1 !important; }
            #sheet-container-back main { column-count: 2 !important; }
        }
        body { font-family: 'EB Garamond', serif; background-color: #fdf6e3; color: #3a2d21; }
        .font-fell { font-family: 'IM Fell English SC', serif; }
        .sheet-wrapper { max-width: 8.5in; margin: 1rem auto; position: relative; }
        .sheet-container {
            border: 2px solid #5c4d3d; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            background-image: url('https://www.transparenttextures.com/patterns/old-paper.png');
            background-color: #fdf6e3; display: none; flex-direction: column;
        }
        @media (max-width: 1023px) {
            .sheet-container { height: auto; min-height: 0; }
            .page-break { page-break-after: unset; margin-bottom: 1rem; }
        }
        .sheet-visible { display: flex; }
        .header-main h1 { color: #8c1d1d; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        .section-header {
            font-family: 'IM Fell English SC', serif; font-weight: 400; font-size: 1.5rem; color: #8c1d1d;
            border-bottom: 2px solid #c9b7a2; padding-bottom: 0.25rem; margin-bottom: 0.75rem; letter-spacing: 0.05em;
        }
        .stat-box { border: 1px solid #c9b7a2; background-color: rgba(255, 255, 255, 0.2); border-radius: 2px; padding: 0.5rem; text-align: center; }
        .ability-score { font-family: 'EB Garamond', serif; font-size: 1.75rem; font-weight: 700; }
        .ability-modifier {
            font-size: 1rem; font-weight: 700; border: 1px solid #3a2d21; border-radius: 50%;
            width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;
            margin: 0.25rem auto 0; background-color: #eaddc7;
        }
        .skill-list li { padding: 0.1rem 0; line-height: 1.2; border-bottom: 1px dotted #dcd1c0; display: flex; justify-content: space-between; align-items: center; }
        .skill-list li:last-child { border-bottom: none; }
        .proficient::before { content: '♦'; margin-right: 0.5em; color: #8c1d1d; }
        .feature-box, .spell-box { margin-bottom: 0.75rem; }
        .feature-title, .spell-title { font-weight: bold; font-family: 'EB Garamond', serif; }
        .feature-desc, .spell-desc { font-size: 0.9rem; color: #5c4d3d; font-style: italic; margin-top: 0.25rem; }
        .attack-box { padding: 0.5rem; border: 1px solid #c9b7a2; border-radius: 0; background-color: transparent; }
        .bordered-section { border: 1px solid #c9b7a2; padding: 0.75rem; background-color: rgba(255,255,255,0.1); }
        .save-dot { width: 1rem; height: 1rem; border-radius: 50%; border: 1px solid #3a2d21; background-color: rgba(0,0,0,0.05); }
        .control-panel button, .icon-button, .editor-button {
            background-color: #8c1d1d; color: #fdf6e3; border: 1px solid #5c4d3d;
            padding: 0.5rem; border-radius: 2px; cursor: pointer; transition: background-color 0.2s;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .control-panel button:hover, .icon-button:hover, .editor-button:hover { background-color: #6a1616; }
        .control-panel select, .control-panel input[type=text] { background-color: #eaddc7; border: 1px solid #5c4d3d; padding: 0.5rem; border-radius: 2px; }
        .usage-tracker { display: inline-flex; align-items: center; gap: 0.25rem; margin-left: 0.75rem; }
        .usage-box, .spell-slot-box, .edit-skill-checkbox {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 0.9rem; height: 0.9rem; border: 1px solid #5c4d3d; background-color: #fdf6e3;
            cursor: pointer; position: relative; border-radius: 2px; flex-shrink: 0;
        }
        .usage-box:checked, .spell-slot-box:checked, .edit-skill-checkbox:checked { background-color: #3a2d21; }
        .usage-box:checked::after, .spell-slot-box:checked::after, .edit-skill-checkbox:checked::after {
            content: '✓'; color: #fdf6e3; position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%); font-size: 0.7rem; line-height: 1;
        }
        .edit-skill-checkbox:disabled { background-color: #c9b7a2; cursor: not-allowed; }
        .edit-skill-checkbox:disabled:checked { background-color: #5c4d3d; }
        
        .spell-slot-group { display: flex; align-items: center; margin-bottom: 0.5rem; }
        .spell-slot-label { width: 80px; font-weight: bold; }
        .sheet-controls { position: absolute; top: 1.5rem; right: 1.5rem; z-index: 10; display: none; }
        .editor-button { padding: 0.5rem 1rem; }
        .flowing-columns { column-count: 2; column-gap: 1.5rem; height: 100%; }
        .flowing-columns > section { break-inside: avoid; }
        .gemini-button { background-color: #4a3362; color: #f3e8ff; border-color: #3e2753; font-size: 0.8rem; padding: 0.25rem 0.5rem; }
        .gemini-button:hover { background-color: #3e2753; }
        
        .info-button { background: none; border: none; padding: 0 0.5rem; cursor: pointer; color: #5c4d3d; }
        .info-tooltip {
            display: none; position: absolute; z-index: 100;
            background-color: #fdf6e3; border: 1px solid #5c4d3d;
            border-radius: 4px; padding: 0.75rem;
            max-width: 250px; text-align: left; font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .edit-mode-input, .edit-mode-select { width: 100%; background-color: #fdf6e3; border: 1px dashed #c9b7a2; padding: 2px 4px; }
        .edit-mode-textarea { width: 100%; background-color: #fdf6e3; border: 1px dashed #c9b7a2; padding: 2px 4px; min-height: 50px; font-style: italic; font-size: 0.9rem;}
        .edit-stat { width: 40px; text-align: center; background-color: #fdf6e3; border: 1px solid #c9b7a2; }
        .edit-mode-small-btn { font-size: 0.7rem; padding: 0 4px; margin-left: 8px; border-radius: 50%; background-color: #8c1d1d; color: #fdf6e3; border: none; cursor: pointer; }
        
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #8c1d1d; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 50; display: flex; align-items: center; justify-content: center; }
        .modal-content { background-color: #fdf6e3; padding: 2rem; border: 2px solid #5c4d3d; max-width: 500px; text-align: center; }
    </style>
</head>
<body class="p-4">
    <div id="control-panel-main" class="control-panel max-w-5xl mx-auto p-4 mb-4 no-print bg-amber-50 rounded shadow-md border border-amber-200">
        <h1 class="font-fell text-3xl text-red-800 text-center mb-4">Character Sheet Creator</h1>
        <div class="space-y-4">
            <div id="local-controls" class="grid md:grid-cols-2 gap-x-4 gap-y-2 items-center">
                <div class="flex justify-start items-center gap-2 md:gap-4">
                    <button id="new-char-btn" title="New Character"><i data-feather="file-plus"></i></button>
                    <label for="character-select" class="font-fell">Load:</label>
                    <select id="character-select" class="flex-grow"></select>
                    <label for="char-file-input" class="icon-button" title="Load character from file">
                        <i data-feather="folder"></i>
                    </label>
                    <input type="file" id="char-file-input" accept=".json" class="hidden">
                </div>
                 <div class="flex justify-end items-center gap-4">
                    <label for="session-name" class="font-fell">Session:</label>
                    <input type="text" id="session-name" placeholder="E.g., Westmarches" class="flex-grow">
                </div>
                <div class="col-span-1 md:col-span-2 flex justify-end">
                    <button id="clear-library-btn" class="bg-gray-600 hover:bg-gray-700 text-xs py-1 px-2">Clear Entire Library</button>
                </div>
            </div>
             <div class="border-t border-amber-200 pt-4 mt-4">
                <h2 class="font-fell text-xl text-center text-purple-900 mb-2">✨ AI Character Generator ✨</h2>
                <div class="flex items-center gap-4">
                    <input type="text" id="gemini-prompt" class="flex-grow" placeholder="Describe a character, e.g., 'a grumpy dwarf cleric'">
                    <button id="generate-character-btn" class="gemini-button">Generate</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="welcome-message" class="text-center p-10 max-w-4xl mx-auto bg-amber-50 rounded shadow-md border border-amber-200">
        <h2 class="font-fell text-2xl">Welcome, Gamemaster!</h2>
        <p class="mt-2">Start by creating a <button id="welcome-new-char-btn" class="text-red-800 font-bold underline">new character</button> or loading a character file.</p>
    </div>

    <div class="sheet-wrapper">
        <div id="sheet-controls" class="no-print space-x-2">
            <button id="edit-char-btn" class="icon-button" title="Toggle Edit Mode" disabled><i data-feather="edit-2"></i></button>
            <button id="save-library-btn" class="icon-button" title="Save to Browser Library" disabled><i data-feather="save"></i></button>
            <button id="export-json-btn" class="icon-button" title="Export as JSON file" disabled><i data-feather="download"></i></button>
            <button id="print-btn" class="icon-button" title="Print Sheet"><i data-feather="printer"></i></button>
            <button id="share-char-btn" class="icon-button" title="Share Online" disabled><i data-feather="share-2"></i></button>
        </div>
        <!-- Page Containers -->
        <div id="sheet-container-front" class="sheet-container p-6 page-break"></div>
        <div id="sheet-container-back" class="sheet-container p-6"></div>
    </div>

    <!-- MODALS & TOOLTIPS -->
    <div id="info-tooltip" class="info-tooltip"></div>
    <div id="loading-modal" class="modal-backdrop hidden no-print">
        <div class="modal-content">
            <div id="loading-spinner" class="loading-spinner mx-auto"></div>
            <p id="loading-text" class="mt-4 font-fell text-lg"></p>
        </div>
    </div>
    <div id="share-modal" class="modal-backdrop hidden no-print">
        <div class="modal-content">
            <h2 class="font-fell text-2xl text-red-800">Share Your Character</h2>
            <p class="my-4">Anyone with this link can view this version of your character sheet.</p>
            <input type="text" id="share-url-input" readonly class="w-full p-2 border border-amber-400 bg-amber-50 text-center">
            <div class="mt-4 flex justify-center gap-4">
                <button id="copy-share-url-btn" class="editor-button">Copy Link</button>
                <button id="close-share-modal-btn" class="editor-button bg-gray-600">Close</button>
            </div>
        </div>
    </div>


<script type="module">
    // Start by fetching the schema, as it's needed for AI features.
    fetch('./schema.json')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok for schema.json');
            }
            return response.json();
        })
        .catch(error => {
            console.error("Error loading schema.json:", error);
            console.warn("AI character generation will be disabled.");
            return null;
        })
        .then(schemaData => {
            // Now that we have schema data (or null), load the rules and start the app.
            import('./rules.js')
                .then(rulesModule => {
                    runApp(rulesModule, schemaData);
                })
                .catch(error => {
                    console.warn("WARNING: rules.js not found. The character creator will run in basic mode without rule validation or auto-population. Dropdowns for Class and Species will be replaced with text inputs.", error);
                    const fallbackRules = {
                        ABILITIES: { str: "Strength", dex: "Dexterity", con: "Constitution", int: "Intelligence", wis: "Wisdom", cha: "Charisma" },
                        SKILLS: { "Acrobatics": "dex", "Animal Handling": "wis", "Arcana": "int", "Athletics": "str", "Deception": "cha", "History": "int", "Insight": "wis", "Intimidation": "cha", "Investigation": "int", "Medicine": "wis", "Nature": "int", "Perception": "wis", "Performance": "cha", "Persuasion": "cha", "Religion": "int", "Sleight of Hand": "dex", "Stealth": "dex", "Survival": "wis" },
                        CLASSES: {},
                        SPECIES: {},
                        PROFICIENCY_BONUS_PROGRESSION: { 1: 2, 5: 3, 9: 4, 13: 5, 17: 6 },
                        SPELL_SLOT_PROGRESSION: {},
                        BACKGROUNDS: {}
                    };
                    runApp(fallbackRules, schemaData);
                });
        });

    async function runApp(DND_RULES, schema) {
        let isEditing = false;
        let currentCharacterData = null;
        let characterSchema = schema;
        let sourceCharacterId = null; 
        const STORAGE_KEY = 'dndCharacterLibrary';

        // --- SUPABASE SETUP ---
        const SUPABASE_URL = 'https://hqnxqotwtzeheydnaaio.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhxbnhxb3R3dHplaGV5ZG5hYWlvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1OTk5MjIsImV4cCI6MjA3NjE3NTkyMn0.0zB-cPMBx-SJkZyu0_MgGoz71xvrp-83r1tUEVg9MeQ';
        let supabaseClient = null;

        if (SUPABASE_URL !== 'YOUR_SUPABASE_PROJECT_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
            try {
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase client initialized.");
            } catch (e) {
                console.error("Error initializing Supabase client:", e.message);
            }
        } else {
            console.warn("Supabase credentials not found. Online sharing will be disabled.");
        }
        
        // --- DOM Elements ---
        const fileInput = document.getElementById('char-file-input');
        const characterSelect = document.getElementById('character-select');
        const sessionNameInput = document.getElementById('session-name');
        const printBtn = document.getElementById('print-btn');
        const clearLibraryBtn = document.getElementById('clear-library-btn');
        const welcomeMessage = document.getElementById('welcome-message');
        const sheetFront = document.getElementById('sheet-container-front');
        const sheetBack = document.getElementById('sheet-container-back');
        const newCharBtn = document.getElementById('new-char-btn');
        const welcomeNewCharBtn = document.getElementById('welcome-new-char-btn');
        const editCharBtn = document.getElementById('edit-char-btn');
        const saveLibraryBtn = document.getElementById('save-library-btn');
        const shareCharBtn = document.getElementById('share-char-btn');
        const exportJsonBtn = document.getElementById('export-json-btn');
        const sheetControls = document.getElementById('sheet-controls');
        const generateBtn = document.getElementById('generate-character-btn');
        const geminiPromptInput = document.getElementById('gemini-prompt');
        const loadingModal = document.getElementById('loading-modal');
        const loadingText = document.getElementById('loading-text');
        const infoTooltip = document.getElementById('info-tooltip');

        if (!characterSchema) {
            generateBtn.disabled = true;
            geminiPromptInput.placeholder = "AI features disabled: schema not found.";
        } else {
             console.log("Character schema loaded successfully.");
        }

        const showLoading = (text) => {
            loadingText.textContent = text;
            loadingModal.classList.remove('hidden');
        };
        const hideLoading = () => loadingModal.classList.add('hidden');

        const getMod = (score) => Math.floor((score - 10) / 2);
        const formatMod = (mod) => mod >= 0 ? `+${mod}` : mod.toString();

        const calculateMaxHp = (level, className, conScore) => {
            const classData = DND_RULES.CLASSES[className];
            if (!classData) return 1;
            const conMod = getMod(conScore);
            let maxHp = classData.hitDice + conMod;
            if (level > 1) {
                const hpGainPerLevel = classData.hitDiceAverage + conMod;
                maxHp += (level - 1) * Math.max(1, hpGainPerLevel);
            }
            return maxHp;
        };

        const getLibrary = () => JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
        const saveLibrary = (library) => localStorage.setItem(STORAGE_KEY, JSON.stringify(library));

        const showSheets = () => {
            welcomeMessage.style.display = 'none';
            sheetFront.classList.add('sheet-visible');
            sheetBack.classList.add('sheet-visible');
            sheetControls.style.display = 'flex';
            editCharBtn.disabled = false;
            saveLibraryBtn.disabled = false;
            exportJsonBtn.disabled = false;
            if (supabaseClient) shareCharBtn.disabled = false;
        };

        const populateCharacterSelect = () => {
            const library = getLibrary();
            characterSelect.innerHTML = '<option value="">Select a character...</option>';
            Object.entries(library).forEach(([session, chars]) => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = session;
                chars.forEach(char => {
                    const option = new Option(char.name, `${session}|${char.name}`);
                    optgroup.appendChild(option);
                });
                characterSelect.appendChild(optgroup);
            });
        };

        const handleFileLoad = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.name || !data.abilityScores || !data.proficiencies) {
                        throw new Error("Invalid character sheet format.");
                    }
                    currentCharacterData = data;
                    isEditing = false;
                    sourceCharacterId = null;
                    renderCharacterSheet();
                    handleSaveToLibrary();
                } catch (error) {
                    alert(`Error loading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            fileInput.value = '';
        };
        
        const handleSaveToLibrary = () => {
            if (isEditing) gatherDataFromForm();
            if (!currentCharacterData) return;
            const sessionName = sessionNameInput.value.trim() || 'Uncategorized';
            const library = getLibrary();
            if (!library[sessionName]) library[sessionName] = [];
            const existingIndex = library[sessionName].findIndex(c => c.name === currentCharacterData.name);
            if (existingIndex > -1) {
                library[sessionName][existingIndex] = currentCharacterData;
            } else {
                library[sessionName].push(currentCharacterData);
            }
            saveLibrary(library);
            populateCharacterSelect();
            characterSelect.value = `${sessionName}|${currentCharacterData.name}`;
            saveLibraryBtn.innerHTML = `<i data-feather="save"></i>`;
            saveLibraryBtn.title = `Save to Browser Library`;
            feather.replace();
        };

        const loadFromSelect = () => {
            const [sessionName, charName] = characterSelect.value.split('|');
            if (!sessionName || !charName) return;
            const library = getLibrary();
            const data = library[sessionName]?.find(c => c.name === charName);
            if (data) {
                currentCharacterData = data;
                isEditing = false;
                sourceCharacterId = null;
                renderCharacterSheet();
                sessionNameInput.value = sessionName;
            }
        };

        const clearLibrary = () => {
            if (confirm("Are you sure you want to delete all saved characters?")) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        };
        
        const handleNewCharacter = () => {
            currentCharacterData = createBlankCharacter();
            isEditing = true;
            sourceCharacterId = null;
            renderCharacterSheet();
        };

        const handleEditToggle = () => {
            if (isEditing) gatherDataFromForm();
            isEditing = !isEditing;
            renderCharacterSheet();
        };

        const handleExport = () => {
            if (isEditing) gatherDataFromForm();
            if (!currentCharacterData) return;
            const jsonString = JSON.stringify(currentCharacterData, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentCharacterData.name.toLowerCase().replace(/\s+/g, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        
        const handleFormChange = () => {
            if (isEditing) {
                gatherDataFromForm();
                renderCharacterSheet();
            }
        };

        async function handleGenerateCharacter() {
            const userPrompt = geminiPromptInput.value.trim();
            if (!userPrompt) { alert("Please describe the character you want to generate."); return; }
            if (!characterSchema) { alert("Character schema is not loaded. AI generation is disabled."); return; }
            showLoading("The mists of creation are swirling...");
            try {
                const response = await fetch(`/.netlify/functions/generate-character`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: userPrompt, schema: characterSchema })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API call failed with status: ${response.status} ${response.statusText} - ${errorText}`);
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content?.parts?.[0]?.text) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const generatedData = JSON.parse(jsonText);
                    currentCharacterData = { ...createBlankCharacter(), ...generatedData };
                    gatherDataFromForm();
                    isEditing = false;
                    sourceCharacterId = null;
                    renderCharacterSheet();
                    handleSaveToLibrary();
                } else { throw new Error("Invalid response structure from Gemini API."); }
            } catch (error) {
                console.error("Error generating character:", error);
                alert("There was an error generating the character. Please check the console for more details.");
            } finally { hideLoading(); }
        }
        
        const handlePrint = () => {
            const wasEditing = isEditing;
            if (wasEditing) {
                isEditing = false;
                renderCharacterSheet();
            }
            setTimeout(() => {
                window.onafterprint = () => {
                    if (wasEditing) {
                        isEditing = true;
                        renderCharacterSheet();
                    }
                    window.onafterprint = null;
                };
                window.print();
            }, 100);
        };

        async function handleShareCharacter() {
            if (!supabaseClient) {
                alert("Online sharing is not configured.");
                return;
            }
            if (isEditing) gatherDataFromForm();
            if (!currentCharacterData) return;
            showLoading("Saving character to the archives...");
            try {
                const { data, error } = await supabaseClient
                    .from('characters')
                    .insert([{
                        name: currentCharacterData.name,
                        character_data: currentCharacterData,
                        source_character_id: sourceCharacterId
                    }])
                    .select()
                    .single();

                if (error) throw error;
                const newId = data.id;
                const newUrl = `${window.location.origin}${window.location.pathname}?id=${newId}`;
                
                document.getElementById('share-url-input').value = newUrl;
                document.getElementById('share-modal').classList.remove('hidden');
                
                history.pushState({}, '', newUrl);
                sourceCharacterId = newId;
            } catch (error) {
                console.error("Error sharing character:", error);
                alert(`Could not share character: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        async function loadCharacterFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const characterId = urlParams.get('id');

            if (characterId && supabaseClient) {
                showLoading("Fetching character from the archives...");
                document.getElementById('control-panel-main').style.display = 'none';
                try {
                    const { data, error } = await supabaseClient
                        .from('characters')
                        .select('character_data, id')
                        .eq('id', characterId)
                        .single();
                    
                    if (error) throw error;
                    if (!data) throw new Error("Character not found.");

                    currentCharacterData = data.character_data;
                    isEditing = false;
                    sourceCharacterId = data.id;
                    renderCharacterSheet();
                    saveLibraryBtn.innerHTML = `<i data-feather="copy"></i>`;
                    saveLibraryBtn.title = "Save a Local Copy";
                    feather.replace();
                } catch (error) {
                    console.error("Error loading character from URL:", error);
                    alert(`Could not load character: ${error.message}`);
                    document.getElementById('control-panel-main').style.display = 'block';
                    welcomeMessage.innerHTML = `<h2 class="font-fell text-2xl text-red-800">Error</h2><p>Could not load character from the provided link.</p>`;
                } finally {
                    hideLoading();
                }
                return true;
            }
            return false;
        }


        const pointBuyCosts = { 8: 0, 9: 1, 10: 2, 11: 3, 12: 4, 13: 5, 14: 7, 15: 9 };
        
        window.adjustPointBuyScore = (key, delta) => {
            if (!currentCharacterData) return;
            const currentScore = currentCharacterData.pointBuyBaseScores[key];
            const newScore = currentScore + delta;
            let totalCost = 0;
            Object.values(currentCharacterData.pointBuyBaseScores).forEach(s => totalCost += pointBuyCosts[s]);
            const futureCost = totalCost - pointBuyCosts[currentScore] + pointBuyCosts[newScore];
            if (newScore >= 8 && newScore <= 15 && futureCost <= 27) {
                currentCharacterData.pointBuyBaseScores[key] = newScore;
                handleFormChange();
            }
        };

        let activeTooltip = null;
        function showInfo(e) {
            e.stopPropagation();
            const button = e.currentTarget;
            const type = button.dataset.infoType;
            const selectId = `edit-char-${type}`;
            const select = document.getElementById(selectId) || document.getElementById(`${selectId}-select`);
            if (!select) return;
            
            const selectedKey = select.value;
            let description = '';

            if (type === 'class' && DND_RULES.CLASSES[selectedKey]) description = DND_RULES.CLASSES[selectedKey].description;
            if (type === 'species' && DND_RULES.SPECIES[selectedKey]) description = DND_RULES.SPECIES[selectedKey].description;
            if (type === 'background' && DND_RULES.BACKGROUNDS[selectedKey]) description = DND_RULES.BACKGROUNDS[selectedKey].description;

            if (activeTooltip === button) {
                hideInfo();
                return;
            }

            if (description) {
                const rect = button.getBoundingClientRect();
                infoTooltip.innerHTML = description;
                infoTooltip.style.display = 'block';
                infoTooltip.style.left = `${rect.left}px`;
                infoTooltip.style.top = `${rect.bottom + 5}px`;
                activeTooltip = button;
            }
        }
        function hideInfo() {
            infoTooltip.style.display = 'none';
            activeTooltip = null;
        }

        // --- Event Listeners & Startup ---
        document.body.addEventListener('click', hideInfo);
        infoTooltip.addEventListener('click', (e) => e.stopPropagation());
        fileInput.addEventListener('change', handleFileLoad);
        characterSelect.addEventListener('change', loadFromSelect);
        printBtn.addEventListener('click', handlePrint);
        clearLibraryBtn.addEventListener('click', clearLibrary);
        newCharBtn.addEventListener('click', handleNewCharacter);
        welcomeNewCharBtn.addEventListener('click', handleNewCharacter);
        editCharBtn.addEventListener('click', handleEditToggle);
        saveLibraryBtn.addEventListener('click', handleSaveToLibrary);
        exportJsonBtn.addEventListener('click', handleExport);
        generateBtn.addEventListener('click', handleGenerateCharacter);
        if (supabaseClient) shareCharBtn.addEventListener('click', handleShareCharacter);

        document.getElementById('close-share-modal-btn').addEventListener('click', () => {
            document.getElementById('share-modal').classList.add('hidden');
        });
        document.getElementById('copy-share-url-btn').addEventListener('click', () => {
            const input = document.getElementById('share-url-input');
            input.select();
            input.setSelectionRange(0, 99999); 
            try {
                document.execCommand('copy');
                alert('Link copied to clipboard!');
            } catch (err) {
                alert('Failed to copy link.');
            }
        });
        
        // --- App Initialization ---
        const loadedFromUrl = await loadCharacterFromUrl();
        if (!loadedFromUrl) {
            populateCharacterSelect();
        }
        feather.replace();

        function gatherDataFromForm() {
            if (!currentCharacterData) return;
            const data = { ...currentCharacterData };
            const oldSpecies = currentCharacterData.species;
            const oldBackground = currentCharacterData.background;
            const oldClass = currentCharacterData.class;

            data.name = document.getElementById('edit-char-name').value;
            data.title = document.getElementById('edit-char-title').value;
            data.class = document.getElementById('edit-char-class').value;
            data.level = parseInt(document.getElementById('edit-char-level').value) || 1;
            data.species = document.getElementById('edit-char-species').value;
            data.background = document.getElementById('edit-char-background-select').value;
            
            const backgroundData = DND_RULES.BACKGROUNDS[data.background];
            if (backgroundData) {
                const bonusOptions = backgroundData.abilityScoreIncrease;
                const plusTwoSelect = document.getElementById('bg-bonus-plus-two');
                const plusOneSelect = document.getElementById('bg-bonus-plus-one');
                
                if (data.background !== oldBackground) {
                    data.backgroundBonusSelections.plusTwo = bonusOptions[0];
                    data.backgroundBonusSelections.plusOne = bonusOptions[1];
                } else {
                    let p2 = plusTwoSelect.value;
                    let p1 = plusOneSelect.value;

                    if (p1 === p2) {
                        const alternative = bonusOptions.find(opt => opt !== p2);
                        p1 = alternative;
                    }
                    data.backgroundBonusSelections.plusTwo = p2;
                    data.backgroundBonusSelections.plusOne = p1;
                }
            }

            const finalScores = { ...data.pointBuyBaseScores };
            if (data.backgroundBonusSelections.plusTwo) finalScores[data.backgroundBonusSelections.plusTwo] += 2;
            if (data.backgroundBonusSelections.plusOne) finalScores[data.backgroundBonusSelections.plusOne] += 1;
            data.abilityScores = finalScores;

            data.combat.ac = parseInt(document.getElementById('edit-combat-ac').value) || 10;
            data.combat.speed = document.getElementById('edit-combat-speed').value;
            data.personality.traits = document.getElementById('edit-personality-traits').value;
            data.personality.ideal = document.getElementById('edit-personality-ideal').value;
            data.personality.bond = document.getElementById('edit-personality-bond').value;
            data.personality.flaw = document.getElementById('edit-personality-flaw').value;
            data.equipment = document.getElementById('edit-equipment-list').value;
            
            let featuresFromDOM = [];
            document.querySelectorAll('.edit-feature-item').forEach(item => {
                const title = item.querySelector('.edit-feature-title').value;
                const newFeature = {
                    title: title,
                    desc: item.querySelector('.edit-feature-desc').value,
                    key: item.querySelector('.edit-feature-key').checked
                };
                const originalFeature = currentCharacterData.features.find(f => f.title === title);
                if (originalFeature && originalFeature.uses) {
                    newFeature.uses = originalFeature.uses;
                }
                featuresFromDOM.push(newFeature);
            });

            let featuresToKeep = featuresFromDOM;

            if (data.species !== oldSpecies) {
                const oldSpeciesData = DND_RULES.SPECIES[oldSpecies];
                if (oldSpeciesData) {
                    const oldTraitTitles = oldSpeciesData.traits.map(t => t.title);
                    featuresToKeep = featuresToKeep.filter(f => !oldTraitTitles.includes(f.title));
                }
            }
            if (data.class !== oldClass) {
                const oldClassData = DND_RULES.CLASSES[oldClass];
                if (oldClassData && oldClassData.features) {
                    const oldFeatureTitles = oldClassData.features.map(f => f.title);
                    featuresToKeep = featuresToKeep.filter(f => !oldFeatureTitles.includes(f.title));
                }
            }
            if (data.background !== oldBackground) {
                const oldBackgroundData = DND_RULES.BACKGROUNDS[oldBackground];
                if (oldBackgroundData && oldBackgroundData.feature) {
                    featuresToKeep = featuresToKeep.filter(f => f.title !== oldBackgroundData.feature.title);
                }
            }

            let newFeatures = [];
            if (data.species !== oldSpecies) {
                const newSpeciesData = DND_RULES.SPECIES[data.species];
                if (newSpeciesData) {
                    newFeatures.push(...JSON.parse(JSON.stringify(newSpeciesData.traits)));
                    data.combat.speed = newSpeciesData.speed;
                }
            }
             if (data.class !== oldClass) {
                const newClassData = DND_RULES.CLASSES[data.class];
                if (newClassData && newClassData.features) {
                     newFeatures.push(...JSON.parse(JSON.stringify(newClassData.features)));
                }
            }
            if (data.background !== oldBackground) {
                const newBackgroundData = DND_RULES.BACKGROUNDS[data.background];
                if (newBackgroundData && newBackgroundData.feature) {
                    newFeatures.push(JSON.parse(JSON.stringify(newBackgroundData.feature)));
                }
            }
            
            data.features = [...featuresToKeep, ...newFeatures];

            data.attacks = [];
            document.querySelectorAll('.edit-attack-item').forEach(item => {
                data.attacks.push({
                    name: item.querySelector('.edit-attack-name').value,
                    atkStat: item.querySelector('.edit-attack-atkStat').value,
                    dmgDie: item.querySelector('.edit-attack-dmgDie').value,
                    dmgStat: item.querySelector('.edit-attack-dmgStat').value,
                    dmgBonus: parseInt(item.querySelector('.edit-attack-dmgBonus').value) || 0,
                    type: item.querySelector('.edit-attack-type').value,
                    notes: item.querySelector('.edit-attack-notes').value,
                    weaponMastery: item.querySelector('.edit-attack-weaponMastery').value,
                });
            });

            data.spells = [];
            document.querySelectorAll('.edit-spell-item').forEach(item => {
                data.spells.push({
                    name: item.querySelector('.edit-spell-name').value,
                    level: parseInt(item.querySelector('.edit-spell-level').value) || 0,
                    desc: item.querySelector('.edit-spell-desc').value
                });
            });

            const spellAbilitySelect = document.getElementById('edit-spell-ability');
            if (spellAbilitySelect) {
                data.spellcasting = { ability: spellAbilitySelect.value, spellSlots: {} };
                for (let i = 1; i <= 9; i++) {
                    const slotInput = document.getElementById(`edit-spell-slot-l${i}`);
                    if (slotInput) {
                        const value = parseInt(slotInput.value) || 0;
                        if (value > 0) data.spellcasting.spellSlots[`level${i}`] = value;
                    }
                }
            } else { data.spellcasting = null; }

            let currentProf = 2;
            for (const levelThreshold in DND_RULES.PROFICIENCY_BONUS_PROGRESSION) {
                if (data.level >= parseInt(levelThreshold)) {
                    currentProf = DND_RULES.PROFICIENCY_BONUS_PROGRESSION[levelThreshold];
                }
            }
            data.profBonus = currentProf;
            data.combat.hp_max = calculateMaxHp(data.level, data.class, data.abilityScores.con);
            
            const classData = DND_RULES.CLASSES[data.class];
            
            const skillChecks = document.querySelectorAll('.edit-skill-checkbox');
            const chosenSkills = new Set();
            skillChecks.forEach(cb => {
                if (cb.checked) {
                    chosenSkills.add(cb.dataset.skill);
                }
            });
            data.proficiencies.skills = Array.from(chosenSkills);

            if (data.spellcasting && classData && classData.casterType) {
                const progression = DND_RULES.SPELL_SLOT_PROGRESSION[classData.casterType];
                if (progression && progression[data.level]) {
                    data.spellcasting.spellSlots = { ...progression[data.level] };
                }
            }
            if(classData) data.proficiencies.savingThrows = [...classData.savingThrows];
            
            currentCharacterData = data;
        }

        const createBlankCharacter = () => {
            const defaultBackground = Object.keys(DND_RULES.BACKGROUNDS)[0] || null;
            const defaultClass = Object.keys(DND_RULES.CLASSES)[0] || null;
            const defaultSpecies = Object.keys(DND_RULES.SPECIES)[0] || null;

            let defaultSelections = { plusTwo: null, plusOne: null };
            let backgroundFeature = [];
            if (defaultBackground && DND_RULES.BACKGROUNDS[defaultBackground]) {
                const bgData = DND_RULES.BACKGROUNDS[defaultBackground];
                const bonusOptions = bgData.abilityScoreIncrease;
                defaultSelections = { plusTwo: bonusOptions[0], plusOne: bonusOptions[1] };
                if(bgData.feature) backgroundFeature.push(bgData.feature);
            }

            let classFeatures = [];
            if(defaultClass && DND_RULES.CLASSES[defaultClass] && DND_RULES.CLASSES[defaultClass].features) {
                classFeatures = DND_RULES.CLASSES[defaultClass].features;
            }

            let speciesTraits = [];
            if(defaultSpecies && DND_RULES.SPECIES[defaultSpecies] && DND_RULES.SPECIES[defaultSpecies].traits) {
                speciesTraits = DND_RULES.SPECIES[defaultSpecies].traits;
            }

            return {
                "name": "New Character", "title": "", "class": defaultClass, "level": 1, "species": defaultSpecies, "background": defaultBackground,
                "pointBuyBaseScores": {"str": 8, "dex": 8, "con": 8, "int": 8, "wis": 8, "cha": 8},
                "backgroundBonusSelections": defaultSelections,
                "abilityScores": {"str": 10, "dex": 10, "con": 10, "int": 10, "wis": 10, "cha": 10},
                "profBonus": 2, "proficiencies": {"savingThrows": ["str", "con"], "skills": []},
                "combat": {"ac": 10, "hp_max": 1, "speed": "30ft"},
                "attacks": [], 
                "features": [...speciesTraits, ...classFeatures, ...backgroundFeature], 
                "equipment": "",
                "personality": {"traits": "", "ideal": "", "bond": "", "flaw": ""},
                "spellcasting": null, "spells": []
            }
        };
        
        function renderPointBuyEditorHTML(data) {
            let totalCost = 0;
            Object.values(data.pointBuyBaseScores).forEach(s => totalCost += pointBuyCosts[s]);
            const pointsRemaining = 27 - totalCost;
            let editorHTML = `<div class="text-center mb-2"><span class="font-fell">Points Remaining:</span><span class="font-bold ${pointsRemaining < 0 ? 'text-red-600' : ''}">${pointsRemaining}</span></div>`;
            editorHTML += Object.entries(data.pointBuyBaseScores).map(([key, baseScore]) => {
                const finalScore = data.abilityScores[key];
                const modifier = getMod(finalScore);
                const cost = pointBuyCosts[baseScore];
                return `<div class="flex items-center justify-between p-1 border-b border-dotted border-amber-200"><div class="w-1/4 font-fell text-sm">${DND_RULES.ABILITIES[key].substring(0,3).toUpperCase()}</div><div class="flex items-center gap-2"><button class="icon-button text-xs h-6 w-6" onclick="adjustPointBuyScore('${key}', -1)">-</button><span class="font-bold w-6 text-center">${baseScore}</span><button class="icon-button text-xs h-6 w-6" onclick="adjustPointBuyScore('${key}', 1)">+</button></div><div class="text-xs w-10 text-right">Cost: ${cost}</div><div class="stat-box p-1 w-16 ml-2"><div class="ability-score text-base">${finalScore}</div><div class="ability-modifier text-xs w-6 h-6">${formatMod(modifier)}</div></div></div>`;
            }).join('');
            
            const backgroundData = DND_RULES.BACKGROUNDS[data.background];
            if (backgroundData) {
                const bonusOptions = backgroundData.abilityScoreIncrease;
                const createBonusSelect = (id, bonusValue, selectedValue) => {
                    const options = bonusOptions.map(opt => `<option value="${opt}" ${selectedValue === opt ? 'selected' : ''}>${DND_RULES.ABILITIES[opt]}</option>`).join('');
                    return `<div class="flex items-center justify-between mt-2"><label for="${id}" class="font-fell text-sm">+${bonusValue} Bonus:</label><select id="${id}" class="edit-mode-select w-1/2">${options}</select></div>`
                };
                editorHTML += `<div class="mt-4 pt-2 border-t border-amber-300">`;
                editorHTML += createBonusSelect('bg-bonus-plus-two', 2, data.backgroundBonusSelections.plusTwo);
                editorHTML += createBonusSelect('bg-bonus-plus-one', 1, data.backgroundBonusSelections.plusOne);
                editorHTML += `</div>`;
            }
            return editorHTML;
        }

        function renderCharacterSheet() {
            if (!currentCharacterData) return;
            showSheets();
            
            editCharBtn.innerHTML = isEditing ? `<i data-feather="eye"></i>` : `<i data-feather="edit-2"></i>`;
            editCharBtn.title = isEditing ? "View Mode" : "Edit Mode";
            
            const data = currentCharacterData;
            const abilityMods = Object.fromEntries(Object.entries(data.abilityScores).map(([key, value]) => [key, getMod(value)]));
            const keyFeatures = data.features.filter(f => f.key);
            const otherFeatures = data.features.filter(f => !f.key);
            const createSelectHTML = (id, options, selectedValue, infoType) => {
                const select = `<select id="${id}" class="edit-mode-select">${Object.keys(options).map(key => `<option value="${key}" ${selectedValue === key ? 'selected' : ''}>${key}</option>`).join('')}</select>`;
                const infoButton = `<button class="info-button" data-info-type="${infoType}"><i data-feather="help-circle" class="w-4 h-4"></i></button>`;
                return isEditing ? `<div class="flex items-center">${select}${infoButton}</div>` : selectedValue;
            };

            const backgroundData = DND_RULES.BACKGROUNDS[data.background];
            const classData = DND_RULES.CLASSES[data.class];
            const speciesData = DND_RULES.SPECIES[data.species];
            const lockedSkills = new Set([
                ...(backgroundData?.skills?.map(s => s.toLowerCase().replace(/ /g, '')) || []),
                ...(classData?.skills?.map(s => s.toLowerCase().replace(/ /g, '')) || []),
                ...(speciesData?.skills?.map(s => s.toLowerCase().replace(/ /g, '')) || [])
            ]);


            sheetFront.innerHTML = `<header class="flex flex-col lg:grid lg:grid-cols-3 gap-4 border-b-2 border-black pb-2 mb-3"><div class="lg:col-span-2 header-main">${isEditing ? `<input id="edit-char-name" class="edit-mode-input text-4xl font-fell text-red-800" value="${data.name}">` : `<h1 class="text-4xl font-fell">${data.name}</h1>`}${isEditing ? `<input id="edit-char-title" class="edit-mode-input text-lg italic text-gray-700" value="${data.title}">` : `<p class="text-lg text-gray-700 italic">${data.title}</p>`}</div><div class="text-left lg:text-right text-sm mt-2 lg:mt-0"><p class="flex justify-end items-center"><strong>Class:</strong> ${createSelectHTML('edit-char-class', DND_RULES.CLASSES, data.class, 'class')}</p><p><strong>Level:</strong> ${isEditing ? `<input id="edit-char-level" type="number" min="1" class="edit-stat" value="${data.level}">` : data.level}</p><p class="flex justify-end items-center"><strong>Species:</strong> ${createSelectHTML('edit-char-species', DND_RULES.SPECIES, data.species, 'species')}</p><p class="flex justify-end items-center"><strong>Background:</strong> ${createSelectHTML('edit-char-background-select', DND_RULES.BACKGROUNDS, data.background, 'background')}</p></div></header><main class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 flex-grow"><div class="lg:col-span-1 md:col-span-1 space-y-3 flex flex-col"><section class="${isEditing ? 'grid grid-cols-1 gap-y-1' : 'grid grid-cols-1 sm:grid-cols-2 gap-3'}">${isEditing ? renderPointBuyEditorHTML(data) : Object.entries(data.abilityScores).map(([key, value]) => `<div class="stat-box"><label class="font-fell text-sm">${key.toUpperCase()}</label><div class="ability-score">${value}</div><div class="ability-modifier">${formatMod(abilityMods[key])}</div></div>`).join('')}</section><div class="text-center"><span class="font-bold text-lg mr-2">${formatMod(data.profBonus)}</span><label class="font-fell text-lg">Proficiency Bonus</label></div><section class="bordered-section flex-grow"><h3 class="font-fell font-bold border-b border-gray-400 mb-1">Skills</h3><ul class="text-sm skill-list">${Object.entries(DND_RULES.SKILLS).map(([name, stat]) => {
                const normName = name.toLowerCase().replace(/ /g, '');
                const isProf = data.proficiencies.skills.includes(normName);
                if (isEditing) {
                    const isLocked = lockedSkills.has(normName);
                    return `<li><label class="flex-grow flex items-center"><input type="checkbox" class="edit-skill-checkbox mr-2" data-skill="${normName}" ${isProf ? 'checked' : ''} ${isLocked ? 'disabled' : ''}>${name} <span class="text-gray-500 ml-1">(${stat.toUpperCase()})</span></label><strong class="ml-2">${formatMod(abilityMods[stat] + (isProf ? data.profBonus : 0))}</strong></li>`;
                } else {
                     return `<li class="${isProf ? 'proficient' : ''}"><span>${name} <span class="text-gray-500">(${stat.toUpperCase()})</span></span><strong>${formatMod(abilityMods[stat] + (isProf ? data.profBonus : 0))}</strong></li>`;
                }
            }).join('')}</ul></section></div><div class="lg:col-span-1 md:col-span-1 space-y-3 flex flex-col"><section class="grid grid-cols-3 gap-3 text-center"><div class="stat-box">${isEditing ? `<input type="number" id="edit-combat-ac" class="ability-score edit-stat" value="${data.combat.ac}">` : `<div class="ability-score">${data.combat.ac}</div>`}<div class="font-fell text-xs">ARMOR CLASS</div></div><div class="stat-box"><div class="ability-score">${formatMod(abilityMods.dex)}</div><div class="font-fell text-xs">INIT</div></div><div class="stat-box">${isEditing ? `<input id="edit-combat-speed" class="ability-score edit-stat w-full" value="${data.combat.speed}">` : `<div class="ability-score">${data.combat.speed.replace('ft','<span class="text-base">ft</span>')}</div>`}<div class="font-fell text-xs">SPEED</div></div></section><section class="bordered-section text-center"><label class="font-fell text-lg">Hit Points</label><div class="text-3xl font-bold tracking-wider">${data.combat.hp_max} / ${data.combat.hp_max}</div><div class="mt-2"><label class="font-fell">Hit Dice</label><div class="text-lg font-bold">${data.level}d${(DND_RULES.CLASSES[data.class] || {}).hitDice || 8}</div></div></section><section class="bordered-section text-center"><h3 class="font-fell text-lg mb-2">Death Saves</h3><div class="flex justify-around items-center"><div><span class="text-sm">Successes</span><div class="flex space-x-2 mt-1">${[...Array(3)].map(() => `<div class="save-dot"></div>`).join('')}</div></div><div><span class="text-sm">Failures</span><div class="flex space-x-2 mt-1">${[...Array(3)].map(() => `<div class="save-dot"></div>`).join('')}</div></div></div></section><section class="bordered-section flex-grow"><h3 class="font-fell font-bold border-b border-gray-400 mb-1">Saving Throws</h3><ul class="text-sm skill-list">${Object.entries(DND_RULES.ABILITIES).map(([key, name]) => `<li class="${data.proficiencies.savingThrows.includes(key) ? 'proficient' : ''}"><span>${name}</span><strong>${formatMod(abilityMods[key] + (data.proficiencies.savingThrows.includes(key) ? data.profBonus : 0))}</strong></li>`).join('')}</ul></section><section><h2 class="section-header">Attacks</h2><div id="attacks-section-render" class="space-y-3"></div></section></div><div class="lg:col-span-1 md:col-span-2 space-y-4"><section id="key-features-section" class="text-sm"></section></div></main>`;
            renderKeyFeatures(keyFeatures);
            renderAttacks(data.attacks, abilityMods, data.profBonus);

            let backPageHTML = `<header class="flex justify-between items-baseline border-b-2 border-black pb-3 mb-4"><h1 class="text-3xl font-fell">${data.name}</h1><p class="text-sm italic">Character Details</p></header><main class="flex-grow md:flowing-columns"><section class="bordered-section text-sm mb-4"><h2 class="section-header">Personality</h2>${isEditing ? `<p class="mb-2"><strong>Traits:</strong> <textarea id="edit-personality-traits" class="edit-mode-textarea">${data.personality.traits}</textarea></p><p class="mb-2"><strong>Ideal:</strong> <textarea id="edit-personality-ideal" class="edit-mode-textarea">${data.personality.ideal}</textarea></p><p class="mb-2"><strong>Bond:</strong> <textarea id="edit-personality-bond" class="edit-mode-textarea">${data.personality.bond}</textarea></p><p><strong>Flaw:</strong> <textarea id="edit-personality-flaw" class="edit-mode-textarea">${data.personality.flaw}</textarea></p>` : `<p class="mb-2"><strong>Traits:</strong> <span class="italic">${data.personality.traits}</span></p><p class="mb-2"><strong>Ideal:</strong> <span class="italic">${data.personality.ideal}</span></p><p class="mb-2"><strong>Bond:</strong> <span class="italic">${data.personality.bond}</span></p><p><strong>Flaw:</strong> <span class="italic">${data.personality.flaw}</span></p>`}</section><section class="mb-4"><h2 class="section-header">Features & Traits</h2><div id="features-list-render" class="space-y-3 text-sm"></div></section><section><h2 class="section-header">Equipment</h2>${isEditing ? `<textarea id="edit-equipment-list" class="edit-mode-textarea">${data.equipment}</textarea>`: `<p class="text-sm italic">${data.equipment}</p>`}</section>`;
            if (data.spellcasting) backPageHTML += `<section id="spellcasting-section-render" class="mt-4 flex-grow flex flex-col"></section>`;
            backPageHTML += `</main>`;
            sheetBack.innerHTML = backPageHTML;
            renderFeatureList(otherFeatures);
            if (data.spellcasting) renderSpellcastingSection(data, abilityMods);
            
            if (isEditing) {
                const addChangeListener = (id, handler) => document.getElementById(id)?.addEventListener('change', handler);
                addChangeListener('edit-char-class', handleFormChange);
                addChangeListener('edit-char-species', handleFormChange);
                addChangeListener('edit-char-level', handleFormChange);
                addChangeListener('edit-char-background-select', handleFormChange);
                addChangeListener('bg-bonus-plus-two', handleFormChange);
                addChangeListener('bg-bonus-plus-one', handleFormChange);
                document.querySelectorAll('.edit-skill-checkbox').forEach(cb => cb.addEventListener('change', handleFormChange));

                document.querySelectorAll('.info-button').forEach(btn => {
                    btn.addEventListener('click', showInfo);
                    btn.addEventListener('mouseenter', showInfo);
                    btn.addEventListener('mouseleave', hideInfo);
                });
            }
            feather.replace();
        }
        
        function renderKeyFeatures(features) {
            const container = document.getElementById('key-features-section');
            if (!container) return;
            container.innerHTML = features.length > 0 ? `<h2 class="section-header">Key Features</h2>` + features.map(f => `<div class="feature-box text-sm"><div class="flex items-center flex-wrap"><p class="feature-title">${f.title}</p>${f.uses ? `<div class="usage-tracker">${[...Array(f.uses.total)].map(() => `<input type="checkbox" class="usage-box">`).join('')}<span class="text-xs italic text-gray-500"> per ${f.uses.per}</span></div>` : ''}</div><p class="feature-desc">${f.desc.replace(/<li>/g, '<li class="list-disc list-inside">')}</p></div>`).join('') : '';
        }

        function renderFeatureList(features) {
            const container = document.getElementById('features-list-render');
            if (!container) return;
            if (isEditing) {
                container.innerHTML = currentCharacterData.features.map((f, i) => `<div class="edit-feature-item bordered-section mb-2"><div class="flex justify-between items-center"><input class="edit-mode-input font-bold edit-feature-title" value="${f.title}"><button class="edit-mode-small-btn" onclick="removeListItem('features', ${i})">X</button></div><textarea class="edit-mode-textarea edit-feature-desc">${f.desc}</textarea><div class="mt-1 text-xs"><input type="checkbox" id="key-feature-${i}" class="edit-feature-key" ${f.key ? 'checked' : ''}><label for="key-feature-${i}">Show on front page as Key Feature</label></div></div>`).join('') + `<button class="mt-2 text-sm editor-button" onclick="addListItem('features')">+ Add Feature</button>`;
            } else {
                container.innerHTML = features.length > 0 ? features.map(f => `<div class="feature-box"><div class="flex items-center flex-wrap"><p class="feature-title">${f.title}</p>${f.uses ? `<div class="usage-tracker">${[...Array(f.uses.total)].map(() => `<input type="checkbox" class="usage-box">`).join('')}<span class="text-xs italic text-gray-500"> per ${f.uses.per}</span></div>` : ''}</div><p class="feature-desc">${f.desc.replace(/<li>/g, '<li class="list-disc list-inside">')}</p></div>`).join('') : `<p class="italic text-center text-gray-500 pt-8">No other features.</p>`;
            }
            feather.replace();
        }

        function renderAttacks(attacks, abilityMods, profBonus) {
            const container = document.getElementById('attacks-section-render');
            if (!container) return;

            if (isEditing) {
                let content = attacks.map((attack, i) => {
                    const abilityOptions = Object.keys(DND_RULES.ABILITIES).map(key => `<option value="${key}" ${attack.atkStat === key ? 'selected' : ''}>${DND_RULES.ABILITIES[key]}</option>`).join('');
                    const dmgStatOptions = Object.keys(DND_RULES.ABILITIES).map(key => `<option value="${key}" ${attack.dmgStat === key ? 'selected' : ''}>${DND_RULES.ABILITIES[key]}</option>`).join('');
                    return `<div class="edit-attack-item bordered-section mb-2 p-2"><div class="flex justify-between items-center mb-2"><input class="edit-mode-input font-bold edit-attack-name" value="${attack.name}" placeholder="Attack Name"><button class="edit-mode-small-btn" onclick="removeAttack(${i})">X</button></div><div class="grid grid-cols-2 sm:grid-cols-4 gap-2 text-xs"><div><label>Atk Stat</label><select class="edit-mode-select edit-attack-atkStat">${abilityOptions}</select></div><div><label>Dmg Die</label><input class="edit-mode-input edit-attack-dmgDie" value="${attack.dmgDie}" placeholder="e.g., 1d8"></div><div><label>Dmg Stat</label><select class="edit-mode-select edit-attack-dmgStat">${dmgStatOptions}</select></div><div><label>Dmg Bonus</label><input type="number" class="edit-mode-input edit-attack-dmgBonus" value="${attack.dmgBonus || 0}"></div></div><div class="grid grid-cols-2 gap-2 mt-2 text-xs"><div><label>Dmg Type</label><input class="edit-mode-input edit-attack-type" value="${attack.type}" placeholder="e.g., Slashing"></div><div><label>Mastery</label><input class="edit-mode-input edit-attack-weaponMastery" value="${attack.weaponMastery || ''}" placeholder="e.g., Vex"></div></div><div class="mt-2 text-xs"><label>Notes</label><textarea class="edit-mode-textarea text-xs edit-attack-notes">${attack.notes || ''}</textarea></div></div>`;
                }).join('');
                content += `<button class="mt-2 text-sm editor-button" onclick="addAttack()">+ Add Attack</button>`;
                container.innerHTML = content;
            } else {
                const content = attacks.map(attack => {
                    return `<div class="attack-box">
                                <div class="flex justify-between items-baseline flex-wrap">
                                    <strong>${attack.name}:</strong> 
                                    <span class="text-right text-sm whitespace-nowrap">
                                        <strong>Atk:</strong> ${formatMod(abilityMods[attack.atkStat] + profBonus)} | 
                                        <strong>Dmg:</strong> ${attack.dmgDie}${formatMod(abilityMods[attack.dmgStat] + (attack.dmgBonus || 0))} ${attack.type}
                                    </span>
                                </div>
                                <p class="text-xs text-gray-600 italic mt-1">${attack.weaponMastery ? `<span class="font-bold not-italic text-red-800">${attack.weaponMastery}:</span> ` : ''}${attack.notes || ''}</p>
                            </div>`;
                }).join('');
                container.innerHTML = attacks.length > 0 ? content : `<p class="italic text-center text-gray-500">No attacks defined.</p>`;
            }
        }
        
        function renderSpellcastingSection(data, abilityMods) {
            const container = document.getElementById('spellcasting-section-render');
            if (!container) return;
            const stLabels = DND_RULES.ABILITIES;
            if (isEditing) {
                 container.innerHTML = `<h2 class="section-header">Spellcasting <button onclick="toggleSpellcaster(false)" class="edit-mode-small-btn" title="Remove Spellcaster Status">X</button></h2><div class="mb-2"><label class="font-fell">Ability:</label><select id="edit-spell-ability" class="edit-mode-select w-auto">${Object.keys(stLabels).map(key => `<option value="${key}" ${data.spellcasting.ability === key ? 'selected' : ''}>${stLabels[key]}</option>`).join('')}</select></div><h3 class="font-fell text-lg mb-2">Spell Slots</h3><div class="grid grid-cols-3 gap-x-4 gap-y-2 mb-4">${[...Array(9)].map((_, i) => `<div><label class="text-sm">Level ${i + 1}:</label><input type="number" id="edit-spell-slot-l${i + 1}" class="edit-stat w-12" value="${(data.spellcasting.spellSlots && data.spellcasting.spellSlots[`level${i + 1}`]) || 0}"></div>`).join('')}</div><div id="spells-list-render" class="space-y-3 text-sm flex-grow"></div>`;
                 renderSpellList(data.spells);
            } else if (data.spellcasting) {
                const spellMod = abilityMods[data.spellcasting.ability];
                const spellSaveDC = 8 + data.profBonus + spellMod;
                const spellAttack = data.profBonus + spellMod;
                container.innerHTML = `<h2 class="section-header">Spellcasting</h2><div class="grid grid-cols-3 gap-2 text-center mb-4"><div class="stat-box text-sm"><div class="font-bold text-base">${stLabels[data.spellcasting.ability]}</div><div class="font-fell text-xs">ABILITY</div></div><div class="stat-box text-sm"><div class="font-bold text-base">${spellSaveDC}</div><div class="font-fell text-xs">SAVE DC</div></div><div class="stat-box text-sm"><div class="font-bold text-base">${formatMod(spellAttack)}</div><div class="font-fell text-xs">ATTACK BONUS</div></div></div><div class="mb-4">${(data.spellcasting.spellSlots && Object.entries(data.spellcasting.spellSlots).map(([level, total]) => total > 0 ? `<div class="spell-slot-group"><span class="spell-slot-label">Level ${level.replace('level','')}</span><div class="flex flex-wrap gap-2">${[...Array(total)].map(() => `<input type="checkbox" class="spell-slot-box">`).join('')}</div></div>` : '').join('')) || ''}</div><div id="spells-list-render" class="space-y-3 text-sm flex-grow"></div>`;
                renderSpellList(data.spells);
            }
            feather.replace();
        }
        
        function renderSpellList(spells) {
            const container = document.getElementById('spells-list-render');
            if (!container) return;
            if(isEditing && currentCharacterData.spellcasting === null){
                container.innerHTML = `<div class="text-center p-8 bordered-section"><p class="italic text-gray-600 mb-4">This character is not a spellcaster.</p><button onclick="toggleSpellcaster(true)" class="editor-button">Make Spellcaster</button></div>`;
                return;
            }
            const spellContent = spells.map((s, i) => isEditing ? `<div class="edit-spell-item bordered-section mb-2"><input class="edit-mode-input font-bold edit-spell-name" value="${s.name}" placeholder="Spell Name"><input type="number" class="edit-mode-input text-xs w-16 mt-1 edit-spell-level" value="${s.level}" placeholder="Lvl"><textarea class="edit-mode-textarea mt-1 edit-spell-desc">${s.desc}</textarea><button class="edit-mode-small-btn" onclick="removeListItem('spells', ${i})">X</button></div>` : `<div class="spell-box"><p class="spell-title">${s.name} <span class="text-xs font-normal italic"> (Lvl ${s.level})</span></p><p class="spell-desc">${s.desc}</p></div>`).join('');
            const addSpellButton = isEditing ? `<button class="mt-2 text-sm editor-button" onclick="addListItem('spells')">+ Add Spell</button>` : '';
            const noSpellsMessage = !isEditing && spells.length === 0 ? `<p class="italic text-center text-gray-500 pt-8">No spells known.</p>` : '';
            container.innerHTML = spellContent + addSpellButton + noSpellsMessage;
        }
        
        window.toggleSpellcaster = (makeCaster) => {
            gatherDataFromForm();
            if (makeCaster) {
                currentCharacterData.spellcasting = { ability: 'int', spellSlots: { level1: 2 } };
            } else {
                currentCharacterData.spellcasting = null;
            }
            renderCharacterSheet();
        };
        window.addListItem = (type) => {
            gatherDataFromForm();
            if (type === 'features') currentCharacterData.features.push({title: "New Feature", desc: "", key: false});
            else if (type === 'spells') currentCharacterData.spells.push({name: "New Spell", level: 1, desc: ""});
            renderCharacterSheet();
        };
        window.removeListItem = (type, index) => {
            gatherDataFromForm();
            if (type === 'features') currentCharacterData.features.splice(index, 1);
            else if (type === 'spells') currentCharacterData.spells.splice(index, 1);
            renderCharacterSheet();
        };
        window.addAttack = () => {
            gatherDataFromForm();
            currentCharacterData.attacks.push({ name: "New Attack", atkStat: "str", dmgDie: "1d6", dmgStat: "str", dmgBonus: 0, type: "Slashing", notes: "", weaponMastery: "" });
            renderCharacterSheet();
        };
        window.removeAttack = (index) => {
            gatherDataFromForm();
            currentCharacterData.attacks.splice(index, 1);
            renderCharacterSheet();
        };
    }
</script>
</body>
</html>